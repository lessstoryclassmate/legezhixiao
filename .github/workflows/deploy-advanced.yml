name: Deploy AI Novel Editor

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  PROJECT_NAME: ai-novel-editor
  DEPLOY_DIR: /opt/ai-novel-editor

jobs:
  # 代码质量检查
  quality-check:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: Install dependencies
      run: |
        cd backend
        pip install -r requirements.txt
        
    - name: Run Python linting
      run: |
        cd backend
        python -m flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
        
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        
    - name: Install frontend dependencies
      run: |
        cd frontend
        echo "📦 准备安装前端依赖..."
        echo "=== 当前目录内容 ==="
        ls -la
        
        echo "=== 检查 package.json ==="
        if [ -f "package.json" ]; then
          echo "✅ package.json 存在"
          cat package.json | head -10
        else
          echo "❌ package.json 不存在"
          exit 1
        fi
        
        echo "=== 检查 package-lock.json ==="
        if [ -f "package-lock.json" ]; then
          echo "✅ package-lock.json 存在"
          echo "文件大小: $(wc -c < package-lock.json) 字节"
          echo "lockfileVersion: $(grep -o '"lockfileVersion": [0-9]*' package-lock.json | head -1)"
        else
          echo "❌ package-lock.json 不存在，将使用 npm install"
        fi
        
        echo "=== 检查 Node.js 和 npm 版本 ==="
        echo "Node.js: $(node --version)"
        echo "npm: $(npm --version)"
        
        echo "📦 尝试使用 npm ci 安装依赖..."
        if npm ci --verbose; then
          echo "✅ npm ci 安装成功"
        else
          echo "❌ npm ci 失败，尝试使用 npm install..."
          echo "=== 清理可能的损坏状态 ==="
          rm -rf node_modules package-lock.json
          echo "=== 使用 npm install 重新安装和生成 lock 文件 ==="
          npm install --verbose
          echo "✅ npm install 安装成功"
        fi
        
        echo "=== 验证依赖安装 ==="
        if [ -d "node_modules" ]; then
          echo "✅ node_modules 目录存在"
          echo "已安装包数量: $(find node_modules -maxdepth 1 -type d | wc -l)"
        else
          echo "❌ node_modules 目录不存在"
          exit 1
        fi
        
    - name: Run frontend linting
      run: |
        cd frontend
        npm run lint

  # 构建测试
  build:
    needs: quality-check
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Install docker-compose
      run: sudo apt-get update && sudo apt-get install -y docker-compose
      
    - name: Create test environment file
      run: |
        cat > .env << EOF
        # 测试环境 - 使用本地容器服务
        MONGODB_HOST=mongodb
        MONGODB_PORT=27017
        MONGODB_DATABASE=ai_novel_db
        REDIS_HOST=redis
        REDIS_PORT=6379
        REDIS_PASSWORD=Lekairong350702
        # AI 服务配置
        SILICONFLOW_API_KEY=sk-test-key
        JWT_SECRET_KEY=test-jwt-secret-key
        # MySQL 数据库配置（仍使用云服务，但CI环境可能无法连接）
        DATABASE_SYSTEMHOST=172.16.16.3
        DATABASE_SYSTEM=novel_data
        DATABASE_USER=lkr
        DATABASE_PASSWORD=Lekairong350702
        DATABASE_NOVELHOST=172.16.16.2
        DATABASE_NOVELDATA=novel_user_data
        DATABASE_NOVELUSER=novel_data_user
        DATABASE_NOVELUSER_PASSWORD=Lekairong350702
        # 服务配置
        SERVER_IP=localhost
        MCP_SERVER_NAME=novel-ai-server
        MCP_SERVER_PORT=8000
        MCP_SERVER_HOST=localhost
        MCP_TOOLS_ENABLED=true
        MCP_TOOLS_LIST=novel_generation,character_creation,plot_analysis,content_review,style_transfer
        NOVEL_GENERATION_MAX_TOKENS=4096
        NOVEL_GENERATION_TEMPERATURE=0.8
        NOVEL_GENERATION_TOP_P=0.9
        SILICONFLOW_DEFAULT_MODEL=deepseek-ai/DeepSeek-V3
        SILICONFLOW_API_URL=https://api.siliconflow.cn/v1/chat/completions
        EOF
      
    - name: 提升 MongoDB vm.max_map_count 参数
      run: sudo sysctl -w vm.max_map_count=1677720
      
    - name: Build Docker images
      run: docker-compose build --no-cache
    
    - name: Verify Docker network setup
      run: |
        echo "🔍 验证 Docker Compose 配置..."
        echo "=== 当前工作目录 ==="
        echo "PWD: $PWD"
        echo "PROJECT: $(basename $PWD)"
        
        echo "=== 检查网络配置 ==="
        # 验证 docker-compose.yml 中的网络配置
        if docker-compose config | grep -A 3 "networks:" | grep -q "app-network"; then
          echo "✅ 发现 app-network 配置"
          docker-compose config | grep -A 10 "networks:"
        else
          echo "❌ app-network 配置缺失，检查 docker-compose.yml"
          exit 1
        fi
        
        echo "🚀 测试网络创建..."
        docker-compose up -d --no-deps mongodb redis
        sleep 15
        
        echo "=== 当前网络列表 ==="
        docker network ls
        
        echo "=== 智能网络检测 ==="
        # 使用增强的网络检测脚本
        chmod +x scripts/simple-network-check.sh
        
        echo "🔍 执行网络检测脚本..."
        if bash scripts/simple-network-check.sh; then
          NETWORK_CHECK_SUCCESS=true
        else
          NETWORK_CHECK_SUCCESS=false
          echo "⚠️ 网络检测脚本返回失败状态，但继续检查结果"
        fi
        
        # 确保环境变量文件存在并可读
        if [ -f /tmp/detected_network.env ]; then
          echo "=== 检测结果文件内容 ==="
          cat /tmp/detected_network.env
          
          # 加载检测结果
          source /tmp/detected_network.env
          
          # 验证变量是否正确设置
          if [ -n "$DETECTED_NETWORK_NAME" ] && [ "$NETWORK_EXISTS" = "true" ]; then
            echo "✅ 网络检测成功: $DETECTED_NETWORK_NAME"
          else
            echo "⚠️ 网络检测结果显示网络不存在或无效"
            echo "DETECTED_NETWORK_NAME: '$DETECTED_NETWORK_NAME'"
            echo "NETWORK_EXISTS: '$NETWORK_EXISTS'"
            
            # 尝试使用docker-compose创建网络
            echo "🔧 尝试通过docker-compose创建网络..."
            docker-compose up --no-start 2>/dev/null || true
            sleep 5
            
            # 重新检查
            echo "🔍 重新检查网络状态..."
            docker network ls
            
            # 再次尝试检测
            if bash scripts/simple-network-check.sh; then
              source /tmp/detected_network.env
              if [ -n "$DETECTED_NETWORK_NAME" ] && [ "$NETWORK_EXISTS" = "true" ]; then
                echo "✅ 重试后网络检测成功: $DETECTED_NETWORK_NAME"
              else
                echo "❌ 重试后仍然无法检测到网络，继续执行但可能会有问题"
              fi
            else
              echo "❌ 重试网络检测仍然失败，但继续执行"
            fi
          fi
        else
          echo "❌ 网络检测结果文件不存在"
          echo "🔧 创建默认网络检测结果..."
          echo "DETECTED_NETWORK_NAME=app-network" > /tmp/detected_network.env
          echo "NETWORK_EXISTS=unknown" >> /tmp/detected_network.env
          echo "⚠️ 使用默认网络名称继续执行"
        fi
        
        echo "🔍 测试服务间网络通信..."
        # 测试 MongoDB 服务发现
        if docker-compose exec -T mongodb mongosh --eval "db.adminCommand('ping')" 2>/dev/null; then
          echo "✅ MongoDB 服务可通过网络访问"
        else
          echo "❌ MongoDB 网络访问失败"
        fi
        
        # 测试 Redis 服务发现
        if docker-compose exec -T redis redis-cli ping 2>/dev/null; then
          echo "✅ Redis 服务可通过网络访问"
        else
          echo "❌ Redis 网络访问失败"
        fi
        
        echo "🛑 停止测试容器..."
        docker-compose down

  # 部署到生产环境
  deploy:
    needs: [quality-check, build]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup SSH
      uses: webfactory/ssh-agent@v0.8.0
      with:
        ssh-private-key: ${{ secrets.SERVER_SSH_KEY }}
        
    - name: Add server to known hosts
      run: ssh-keyscan -H ${{ secrets.SERVER_IP }} >> ~/.ssh/known_hosts
        
    - name: Deploy to production server
      env:
        SERVER_IP: ${{ secrets.SERVER_IP }}
        SILICONFLOW_API_KEY: ${{ secrets.SILICONFLOW_API_KEY }}
        JWT_SECRET_KEY: ${{ secrets.JWT_SECRET_KEY }}
        REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
        PERSONAL_ACCESS_TOKEN: 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
      run: |
        # 创建部署脚本
        cat > deploy_script.sh << 'SCRIPT_EOF'
        #!/bin/bash
        set -e
        
        echo "🚀 开始部署AI小说编辑器..."
        
        # 检查和安装Docker环境
        echo "🔍 检查Docker环境..."
        
        # 检查Docker是否安装
        if ! command -v docker &> /dev/null; then
          echo "❌ Docker未安装，开始安装..."
          
          # 更新包索引
          sudo apt-get update
          
          # 安装必要的包
          sudo apt-get install -y apt-transport-https ca-certificates curl gnupg lsb-release
          
          # 添加Docker官方GPG密钥
          curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
          
          # 设置稳定版仓库
          echo "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
          
          # 安装Docker Engine
          sudo apt-get update
          sudo apt-get install -y docker-ce docker-ce-cli containerd.io
          
          # 启动并启用Docker服务
          sudo systemctl start docker
          sudo systemctl enable docker
          
          # 将当前用户添加到docker组
          sudo usermod -aG docker $USER
          
          echo "✅ Docker安装完成"
        else
          echo "✅ Docker已安装: $(docker --version)"
        fi
        
        # 检查Docker Compose是否安装
        if ! command -v docker-compose &> /dev/null; then
          echo "❌ Docker Compose未安装，开始安装..."
          
          # 下载最新版本的Docker Compose
          DOCKER_COMPOSE_VERSION=$(curl -s https://api.github.com/repos/docker/compose/releases/latest | grep 'tag_name' | cut -d\" -f4)
          sudo curl -L "https://github.com/docker/compose/releases/download/${DOCKER_COMPOSE_VERSION}/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          
          # 添加执行权限
          sudo chmod +x /usr/local/bin/docker-compose
          
          # 创建符号链接
          sudo ln -sf /usr/local/bin/docker-compose /usr/bin/docker-compose
          
          echo "✅ Docker Compose安装完成"
        else
          echo "✅ Docker Compose已安装: $(docker-compose --version)"
        fi
        
        # 验证Docker服务状态
        echo "🔍 验证Docker服务状态..."
        if sudo systemctl is-active --quiet docker; then
          echo "✅ Docker服务正在运行"
        else
          echo "⚠️ Docker服务未运行，尝试启动..."
          sudo systemctl start docker
          sleep 5
          if sudo systemctl is-active --quiet docker; then
            echo "✅ Docker服务启动成功"
          else
            echo "❌ Docker服务启动失败"
            sudo systemctl status docker
            exit 1
          fi
        fi
        
        # 强制确保用户在docker组中
        echo "🔧 确保Docker权限配置..."
        sudo usermod -aG docker $USER
        
        # 强制重新加载用户组（针对脚本执行环境）
        if groups $USER | grep -q docker; then
          echo "✅ 用户已在docker组中"
        else
          echo "⚠️ 用户不在docker组，但已添加。可能需要重新登录或使用sudo"
        fi
        
        # 测试Docker命令（优先尝试不用sudo）
        echo "🔍 测试Docker命令..."
        DOCKER_CMD="docker"
        COMPOSE_CMD="docker-compose"
        
        # 尝试直接运行docker
        if timeout 10 docker run --rm hello-world > /dev/null 2>&1; then
          echo "✅ Docker命令测试成功（无需sudo）"
        else
          echo "⚠️ 直接运行docker失败，尝试sudo..."
          if timeout 10 sudo docker run --rm hello-world > /dev/null 2>&1; then
            echo "✅ Docker命令(sudo)测试成功"
            DOCKER_CMD="sudo docker"
            COMPOSE_CMD="sudo docker-compose"
          else
            echo "❌ Docker命令完全失败，检查安装和服务状态"
            sudo systemctl status docker
            sudo docker version || true
            exit 1
          fi
        fi
        
        echo "📋 使用Docker命令: $DOCKER_CMD"
        echo "📋 使用Compose命令: $COMPOSE_CMD"
        
        # 设置部署目录
        PROJECT_DIR="/opt/ai-novel-editor"
        BACKUP_DIR="/opt/backups/ai-novel-editor-$(date +%Y%m%d_%H%M%S)"
        
        # 创建目录
        sudo mkdir -p "$PROJECT_DIR"
        sudo mkdir -p "$(dirname "$BACKUP_DIR")"
        sudo chown $USER:$USER "$PROJECT_DIR"
        sudo chown $USER:$USER "$(dirname "$BACKUP_DIR")"
        
        # 备份现有部署
        if [ -d "$PROJECT_DIR/.git" ]; then
          echo "📦 备份现有部署..."
          cp -r "$PROJECT_DIR" "$BACKUP_DIR"
          echo "✅ 备份完成: $BACKUP_DIR"
        fi
        
        # 进入项目目录
        cd "$PROJECT_DIR"
        
        # 克隆或更新代码
        if [ -d ".git" ]; then
          echo "📦 更新现有Git仓库..."
          if git fetch origin && git reset --hard origin/main && git clean -fd; then
            echo "✅ 代码更新成功"
          else
            echo "❌ Git更新失败，尝试重新克隆..."
            cd ..
            rm -rf "$PROJECT_DIR"
            mkdir -p "$PROJECT_DIR"
            cd "$PROJECT_DIR"
            
            # 使用改进的克隆逻辑
            echo "🔄 重新克隆代码仓库..."
            echo "📋 仓库信息："
            echo "  - 仓库名称: $GITHUB_REPOSITORY"
            echo "  - Token前缀: ${PERSONAL_ACCESS_TOKEN:0:10}..."
            echo "  - 克隆地址: https://***@github.com/$GITHUB_REPOSITORY"
            
            if git clone https://$PERSONAL_ACCESS_TOKEN@github.com/$GITHUB_REPOSITORY .; then
              echo "✅ 使用Token重新克隆成功"
            else
              echo "❌ Token克隆失败"
              echo "错误详情："
              echo "1. PERSONAL_ACCESS_TOKEN前缀: ${PERSONAL_ACCESS_TOKEN:0:10}..."
              echo "2. 仓库路径: $GITHUB_REPOSITORY"
              exit 1
            fi
          fi
        else
          echo "📦 初始化Git仓库..."
          # 确保目录为空
          if [ "$(ls -A . 2>/dev/null)" ]; then
            echo "⚠️  目录不为空，清理现有文件..."
            find . -maxdepth 1 -not -name '.' -not -name '..' -exec rm -rf {} + 2>/dev/null || true
          fi
          echo "🔄 克隆代码仓库..."
          echo "📋 仓库信息："
          echo "  - 仓库名称: $GITHUB_REPOSITORY"
          echo "  - Token前缀: ${PERSONAL_ACCESS_TOKEN:0:10}..."
          echo "  - 克隆地址: https://***@github.com/$GITHUB_REPOSITORY"
          
          # 使用Token进行克隆
          for i in {1..3}; do
            echo "尝试第 $i 次克隆..."
            
            if git clone https://$PERSONAL_ACCESS_TOKEN@github.com/$GITHUB_REPOSITORY .; then
              echo "✅ 克隆成功"
              break
            else
              echo "❌ 克隆失败"
              if [ $i -eq 3 ]; then
                echo "❌ 所有克隆尝试都失败了"
                echo "请检查："
                echo "1. PERSONAL_ACCESS_TOKEN是否正确: ${PERSONAL_ACCESS_TOKEN:0:10}..."
                echo "2. Token是否有repo权限"
                echo "3. 仓库名称是否正确: $GITHUB_REPOSITORY"
                exit 1
              else
                echo "等待5秒后重试..."
                sleep 5
              fi
            fi
          done
        fi
        
        # 创建环境变量文件
        echo "🔧 配置环境变量..."
        cat > .env << EOF
        # 服务器配置
        SERVER_IP=$SERVER_IP
        SERVER_USER=root
        SERVER_SSH_PORT=22
        SERVER_PORT=22
        # AI 服务配置
        SILICONFLOW_API_KEY=$SILICONFLOW_API_KEY
        SILICONFLOW_DEFAULT_MODEL=deepseek-ai/DeepSeek-V3
        SILICONFLOW_API_URL=https://api.siliconflow.cn/v1/chat/completions
        JWT_SECRET_KEY=$JWT_SECRET_KEY
        # MCP 服务配置
        MCP_SERVER_NAME=novel-ai-server
        MCP_SERVER_PORT=8000
        MCP_SERVER_HOST=$SERVER_IP
        MCP_TOOLS_ENABLED=true
        MCP_TOOLS_LIST=novel_generation,character_creation,plot_analysis,content_review,style_transfer
        NOVEL_GENERATION_MAX_TOKENS=4096
        NOVEL_GENERATION_TEMPERATURE=0.8
        NOVEL_GENERATION_TOP_P=0.9
        # 云数据库配置 - 使用内网 IP
        MONGODB_HOST=172.16.32.2
        MONGODB_PORT=27017
        MONGODB_DATABASE=ai_novel_db
        REDIS_HOST=172.16.32.2
        REDIS_PORT=6379
        REDIS_PASSWORD=$REDIS_PASSWORD
        # MySQL 数据库配置
        DATABASE_PORT=3306
        DATABASE_SYSTEMHOST=172.16.16.3
        DATABASE_SYSTEM=novel_data
        DATABASE_USER=lkr
        DATABASE_PASSWORD=Lekairong350702
        DATABASE_NOVELHOST=172.16.16.2
        DATABASE_NOVELDATA=novel_user_data
        DATABASE_NOVELUSER=novel_data_user
        DATABASE_NOVELUSER_PASSWORD=Lekairong350702
        EOF
        
        echo "🔍 验证云数据库配置..."
        echo "MongoDB: 172.16.32.2:27017/ai_novel_db"
        echo "MySQL系统库: 172.16.16.3:3306/novel_data"
        echo "MySQL用户库: 172.16.16.2:3306/novel_user_data"
        echo "Redis: 172.16.32.2:6379"
        
        # 检查数据库服务可达性（关键！！！）
        echo "🔍 检查数据库服务可达性..."
        DB_CHECK_FAILED=false
        
        # 检查 MongoDB
        echo "🔍 检查MongoDB连接..."
        if timeout 15 bash -c "echo > /dev/tcp/172.16.32.2/27017" 2>/dev/null; then
          echo "✅ MongoDB (172.16.32.2:27017) 端口可连接"
        else
          echo "❌ MongoDB (172.16.32.2:27017) 端口连接失败"
          DB_CHECK_FAILED=true
          echo "MongoDB故障排查："
          echo "  1. 检查MongoDB服务状态"
          echo "  2. 检查防火墙规则"
          echo "  3. 检查网络路由"
        fi
        
        # 检查 Redis
        echo "🔍 检查Redis连接..."
        if timeout 15 bash -c "echo > /dev/tcp/172.16.32.2/6379" 2>/dev/null; then
          echo "✅ Redis (172.16.32.2:6379) 端口可连接"
        else
          echo "❌ Redis (172.16.32.2:6379) 端口连接失败"
          DB_CHECK_FAILED=true
          echo "Redis故障排查："
          echo "  1. 检查Redis服务状态"
          echo "  2. 检查防火墙规则"
        fi
        
        # 检查 MySQL 系统库
        echo "🔍 检查MySQL系统库连接..."
        if timeout 15 bash -c "echo > /dev/tcp/172.16.16.3/3306" 2>/dev/null; then
          echo "✅ MySQL 系统库 (172.16.16.3:3306) 端口可连接"
        else
          echo "❌ MySQL 系统库端口连接失败"
          DB_CHECK_FAILED=true
        fi
        
        # 检查 MySQL 用户库
        echo "🔍 检查MySQL用户库连接..."
        if timeout 15 bash -c "echo > /dev/tcp/172.16.16.2/3306" 2>/dev/null; then
          echo "✅ MySQL 用户库 (172.16.16.2:3306) 端口可连接"
        else
          echo "❌ MySQL 用户库端口连接失败"
          DB_CHECK_FAILED=true
        fi
        
        # 如果数据库连接有问题，给出明确警告但不阻止部署
        if [ "$DB_CHECK_FAILED" = true ]; then
          echo ""
          echo "⚠️⚠️⚠️ 数据库连接检查发现问题 ⚠️⚠️⚠️"
          echo "这很可能是后端服务启动失败的根本原因！"
          echo "后端服务将在连接数据库时卡死或异常退出。"
          echo ""
          echo "建议操作："
          echo "1. 立即检查数据库服务器状态"
          echo "2. 检查网络连通性和防火墙设置"
          echo "3. 确认数据库配置正确"
          echo ""
          echo "继续部署（可能失败）..."
          sleep 10
        else
          echo "✅ 所有数据库服务端口检查通过"
        fi
        
        # 提升 MongoDB vm.max_map_count 参数（虽然用云数据库，但保留以防万一）
        echo "⚙️  提升 MongoDB vm.max_map_count 参数..."
        sudo sysctl -w vm.max_map_count=1677720
        echo "✅ vm.max_map_count 已设置为 1677720"
        
        # 设置脚本权限
        chmod +x scripts/*.sh || true
        
        # 停止现有服务
        echo "🛑 停止现有服务..."
        $COMPOSE_CMD -f docker-compose.production.yml down --remove-orphans || true
        
        # 清理Docker缓存（适度清理）
        echo "🧹 清理Docker缓存..."
        $DOCKER_CMD container prune -f || true
        $DOCKER_CMD image prune -f || true
        
        # 构建服务
        echo "🔧 构建Docker镜像..."
        if $COMPOSE_CMD -f docker-compose.production.yml build --no-cache; then
          echo "✅ Docker镜像构建成功"
        else
          echo "❌ Docker镜像构建失败"
          exit 1
        fi
        
        # 启动服务
        echo "🚀 启动服务..."
        if $COMPOSE_CMD -f docker-compose.production.yml up -d; then
          echo "✅ 服务启动命令执行成功"
        else
          echo "❌ 服务启动命令失败"
          exit 1
        fi
        
        # 立即检查容器状态
        echo "🔍 检查容器状态..."
        $COMPOSE_CMD -f docker-compose.production.yml ps
        
        # 分阶段等待和检查
        echo "⏳ 等待服务初始化..."
        sleep 30
        
        # 检查容器是否还在运行
        echo "🔍 检查容器运行状态..."
        if $COMPOSE_CMD -f docker-compose.production.yml ps | grep -q "Up"; then
          echo "✅ 至少有容器在运行"
        else
          echo "❌ 没有容器在运行，检查启动日志"
          $COMPOSE_CMD -f docker-compose.production.yml ps
          $COMPOSE_CMD -f docker-compose.production.yml logs
          exit 1
        fi
        
        # 检查后端容器状态
        echo "🔍 专项检查后端容器..."
        if $COMPOSE_CMD -f docker-compose.production.yml ps backend | grep -q "Up"; then
          echo "✅ 后端容器正在运行"
          
          # 显示后端容器日志预览
          echo "📋 后端容器启动日志预览:"
          $COMPOSE_CMD -f docker-compose.production.yml logs --tail=20 backend
          
        else
          echo "❌ 后端容器未运行或已退出"
          echo "📋 后端容器状态:"
          $COMPOSE_CMD -f docker-compose.production.yml ps backend
          echo "📋 后端容器日志:"
          $COMPOSE_CMD -f docker-compose.production.yml logs backend
          
          echo "❌ 后端容器启动失败，中止部署"
          exit 1
        fi
        
        # 继续等待服务稳定
        echo "⏳ 等待服务稳定运行..."
        sleep 30
        
        # 再次检查容器状态
        echo "🔍 二次检查容器状态..."
        $COMPOSE_CMD -f docker-compose.production.yml ps
        
        # 检查服务健康状态
        echo "🔍 开始健康检查..."
        chmod +x scripts/check-backend-health.sh || echo "健康检查脚本不存在，使用内置检查"
        
        # 尝试健康检查
        HEALTH_CHECK_SUCCESS=false
        for i in {1..5}; do
          echo "🔍 第 $i 次健康检查尝试..."
          
          # 简单的HTTP检查
          if curl -f --max-time 15 --connect-timeout 10 http://localhost:8000/health 2>/dev/null; then
            echo "✅ 后端健康检查通过"
            HEALTH_CHECK_SUCCESS=true
            break
          elif curl -f --max-time 15 --connect-timeout 10 http://localhost:8000/ 2>/dev/null; then
            echo "✅ 后端根路径可访问"
            HEALTH_CHECK_SUCCESS=true
            break
          else
            echo "❌ 第 $i 次健康检查失败"
            if [ $i -lt 5 ]; then
              echo "等待15秒后重试..."
              sleep 15
            fi
          fi
        done
        
        if [ "$HEALTH_CHECK_SUCCESS" = false ]; then
          echo "❌ 所有健康检查都失败了"
          echo "📋 最终容器状态:"
          $COMPOSE_CMD -f docker-compose.production.yml ps
          echo "📋 后端详细日志:"
          $COMPOSE_CMD -f docker-compose.production.yml logs --tail=100 backend
          
          echo "🔍 网络和端口诊断:"
          netstat -tlnp | grep :8000 || echo "端口8000未监听"
          
          # 但不立即退出，继续运行诊断
          echo "⚠️ 健康检查失败，但继续执行诊断脚本"
        else
          echo "✅ 后端服务健康检查通过"
        fi
        fi
        
        echo "✅ 部署完成！"
        SCRIPT_EOF
        
        # 执行部署脚本
        scp deploy_script.sh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }}:/tmp/
        ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }} \
          "export SERVER_IP=\"$SERVER_IP\" && \
           export SILICONFLOW_API_KEY=\"$SILICONFLOW_API_KEY\" && \
           export JWT_SECRET_KEY=\"$JWT_SECRET_KEY\" && \
           export REDIS_PASSWORD=\"$REDIS_PASSWORD\" && \
           export PERSONAL_ACCESS_TOKEN=\"$PERSONAL_ACCESS_TOKEN\" && \
           export GITHUB_REPOSITORY=\"${{ github.repository }}\" && \
           chmod +x /tmp/deploy_script.sh && \
           bash /tmp/deploy_script.sh"
        
    - name: Wait for services to start
      run: |
        echo "⏳ 等待服务启动..."
        sleep 60
        
    - name: Health check
      run: |
        echo "🔍 执行健康检查..."
        
        # 检查前端服务
        if curl -f --max-time 30 http://${{ secrets.SERVER_IP }}:80; then
          echo "✅ 前端服务正常"
        else
          echo "❌ 前端服务异常"
          exit 1
        fi
        
        # 检查后端API
        if curl -f --max-time 30 http://${{ secrets.SERVER_IP }}:8000/health; then
          echo "✅ 后端API正常"
        else
          echo "❌ 后端API异常"
          exit 1
        fi
        
    - name: Deployment notification
      if: always()
      run: |
        if [ "${{ job.status }}" == "success" ]; then
          echo "🎉 部署成功！"
          echo "🌐 前端地址: http://${{ secrets.SERVER_IP }}:80"
          echo "🔧 后端API: http://${{ secrets.SERVER_IP }}:8000"
          echo "📚 API文档: http://${{ secrets.SERVER_IP }}:8000/docs"
        else
          echo "❌ 部署失败！"
        fi